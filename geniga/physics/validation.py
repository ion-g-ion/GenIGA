"""
Physics validation functions for IGA solutions.

This module provides functions to compute PDE residuals for validating
the physicality of solutions generated by diffusion models.
"""

import numpy as np
import torch
import scipy.sparse as sp
from pyiga import bspline, assemble, geometry
from typing import Tuple, Optional, Union


def scipy_sparse_to_torch_csr(sparse_matrix: sp.spmatrix, device: torch.device = None) -> torch.Tensor:
    """
    Convert scipy sparse matrix to torch sparse CSR tensor.
    
    Args:
        sparse_matrix: Scipy sparse matrix
        device: Target device for the tensor
        
    Returns:
        Torch sparse CSR tensor
    """
    # Convert to CSR format for better performance
    csr = sparse_matrix.tocsr()
    
    # Convert indices and values to torch tensors
    crow_indices = torch.from_numpy(csr.indptr).long()
    col_indices = torch.from_numpy(csr.indices).long()
    values = torch.from_numpy(csr.data).float()
    
    # Move to device if specified
    if device is not None:
        crow_indices = crow_indices.to(device)
        col_indices = col_indices.to(device)
        values = values.to(device)
    
    # Create sparse CSR tensor
    shape = sparse_matrix.shape
    sparse_tensor = torch.sparse_csr_tensor(crow_indices, col_indices, values, shape, device=device)
    
    return sparse_tensor


def ensure_tensor_device(tensor: torch.Tensor, target_device: torch.device) -> torch.Tensor:
    """Ensure tensor is on the target device."""
    if tensor.device != target_device:
        return tensor.to(target_device)
    return tensor


def compute_poisson_residual(
    solution: torch.Tensor,
    geo_coeffs: torch.Tensor,
    spline_space: Tuple,
    rhs: Optional[torch.Tensor] = None,
    return_norm: bool = True,
    norm_type: str = "inf"
) -> torch.Tensor:
    """
    Compute the residual for Poisson equation: -∇²u = f.
    
    Assumes Dirichlet boundary conditions on the entire boundary are already
    embedded in the solution. Checks physicality by computing the residual.
    
    Args:
        solution: Solution coefficients with BCs already applied, shape (N,) for 1D or (N, M) for 2D
        geo_coeffs: Geometry parametrization coefficients, shape (N, 2) for 2D
        spline_space: Tuple of B-spline basis for each dimension
        rhs: Right-hand side vector (default: zeros), same shape as solution
        return_norm: If True, return norm of residual; if False, return residual vector
        norm_type: Type of norm ("inf", "2", or "1")
        
    Returns:
        Residual norm (if return_norm=True) or residual vector as torch tensor
    """
    # Get device from solution tensor
    device = solution.device
    dtype = solution.dtype
    
    # Ensure inputs are contiguous (creates copy only if needed, ensures storage exists)
    solution = solution.contiguous()
    geo_coeffs = geo_coeffs.contiguous()
    
    # Get dimensions
    d = len(spline_space)  # spatial dimension
    
    if d == 2:
        n0, n1 = [kvs.numdofs for kvs in spline_space]
        
        # Ensure solution and geo_coeffs are 2D
        if solution.dim() == 1:
            solution_2d = solution.reshape(n0, n1).contiguous()
        else:
            solution_2d = solution.contiguous()
            
        if geo_coeffs.dim() == 1:
            geo_coeffs_2d = geo_coeffs.reshape(n0, n1, 2).contiguous()
        else:
            geo_coeffs_2d = geo_coeffs.contiguous()
            
        # Create geometry object - ensure contiguous before slicing and numpy conversion
        geo_coeffs_2d = geo_coeffs_2d.contiguous()
        geo_x = geo_coeffs_2d[:, :, 0].clone().detach().cpu().numpy()
        geo_y = geo_coeffs_2d[:, :, 1].clone().detach().cpu().numpy()
        geo = geometry.BSplineFunc(spline_space, np.stack([geo_x, geo_y], axis=-1))
    else:
        raise NotImplementedError("Only 2D geometry currently supported")
    
    # Assemble stiffness matrix
    A_scipy = assemble.stiffness(spline_space, geo)
    A_torch = torch.sparse_csr_tensor(torch.tensor(A_scipy.indptr, dtype=torch.int64, device=device), 
                                      torch.tensor(A_scipy.indices, dtype=torch.int64, device=device), 
                                      torch.tensor(A_scipy.data, dtype=dtype, device=device), 
                                      A_scipy.shape, device=device)

    
    # Create RHS if not provided
    if rhs is None:
        rhs_torch = torch.zeros_like(solution_2d, device=device, dtype=dtype)
    else:
        rhs_torch = ensure_tensor_device(rhs, device)
        if rhs_torch.dim() == 1:
            rhs_torch = rhs_torch.reshape(n0, n1)
    
    # Create boundary and interior masks
    bd_mask = torch.ones([n0, n1], device=device, dtype=dtype)
    bd_mask[1:-1, 1:-1] = 0
    int_mask = 1 - bd_mask

    
    # Compute residual
    res_flat = int_mask.flatten() * (A_torch @ (int_mask * solution_2d).flatten()) - int_mask.flatten() * (-A_torch @ (bd_mask * solution_2d).flatten()) - (int_mask * rhs_torch).flatten()
    
    # Reshape back to 2D
    res = res_flat.reshape(n0, n1)
    
    if return_norm:
        if norm_type == "inf":
            return torch.max(torch.abs(res))
        elif norm_type == "2":
            return torch.norm(res)
        elif norm_type == "1":
            return torch.sum(torch.abs(res))
        else:
            raise ValueError(f"Unknown norm type: {norm_type}")
    else:
        return res


def compute_helmholtz_residual(
    solution: torch.Tensor,
    geo_coeffs: torch.Tensor,
    wave_number: Union[float, torch.Tensor],
    spline_space: Tuple,
    rhs: Optional[torch.Tensor] = None,
    return_norm: bool = True,
    norm_type: str = "inf"
) -> torch.Tensor:
    """
    Compute the residual for Helmholtz equation: -∇²u + k²u = f.
    
    Assumes Dirichlet boundary conditions on the entire boundary are already
    embedded in the solution. Checks physicality by computing the residual.
    
    Args:
        solution: Solution coefficients with BCs already applied, shape (N,) for 1D or (N, M) for 2D
        geo_coeffs: Geometry parametrization coefficients, shape (N, 2) for 2D
        wave_number: Wave number k
        spline_space: Tuple of B-spline basis for each dimension
        rhs: Right-hand side vector (default: zeros), same shape as solution
        return_norm: If True, return norm of residual; if False, return residual vector
        norm_type: Type of norm ("inf", "2", or "1")
        
    Returns:
        Residual norm (if return_norm=True) or residual vector as torch tensor
    """
    # Get device from solution tensor
    device = solution.device
    dtype = solution.dtype
    
    # Handle wave number
    if isinstance(wave_number, torch.Tensor):
        k = wave_number
        if k.device != device:
            k = k.to(device)
    else:
        k = torch.tensor(wave_number, device=device, dtype=dtype)
    
    # Ensure inputs are contiguous (creates copy only if needed, ensures storage exists)
    solution = solution.contiguous()
    geo_coeffs = geo_coeffs.contiguous()
    
    # Get dimensions
    d = len(spline_space)  # spatial dimension
    
    if d == 2:
        n0, n1 = [kvs.numdofs for kvs in spline_space]
        
        # Ensure solution and geo_coeffs are 2D
        if solution.dim() == 1:
            solution_2d = solution.reshape(n0, n1).contiguous()
        else:
            solution_2d = solution.contiguous()
            
        if geo_coeffs.dim() == 1:
            geo_coeffs_2d = geo_coeffs.reshape(n0, n1, 2).contiguous()
        else:
            geo_coeffs_2d = geo_coeffs.contiguous()
            
        # Create geometry object - ensure contiguous before slicing and numpy conversion
        geo_coeffs_2d = geo_coeffs_2d.contiguous()
        geo_x = geo_coeffs_2d[:, :, 0].clone().detach().cpu().numpy()
        geo_y = geo_coeffs_2d[:, :, 1].clone().detach().cpu().numpy()
        geo = geometry.BSplineFunc(spline_space, np.stack([geo_x, geo_y], axis=-1))
    else:
        raise NotImplementedError("Only 2D geometry currently supported")
    
    # Assemble stiffness and mass matrices
    A_scipy = assemble.stiffness(spline_space, geo)  # -∇² term
    M_scipy = assemble.mass(spline_space, geo)       # k²u term
    
    # Convert to torch sparse CSR tensors
    A_torch = torch.sparse_csr_tensor(torch.tensor(A_scipy.indptr, dtype=torch.int64, device=device), 
                                      torch.tensor(A_scipy.indices, dtype=torch.int64, device=device), 
                                      torch.tensor(A_scipy.data, dtype=dtype, device=device), 
                                      A_scipy.shape, device=device)
    
    M_torch = torch.sparse_csr_tensor(torch.tensor(M_scipy.indptr, dtype=torch.int64, device=device), 
                                      torch.tensor(M_scipy.indices, dtype=torch.int64, device=device), 
                                      torch.tensor(M_scipy.data, dtype=dtype, device=device), 
                                      M_scipy.shape, device=device)
    
    # Create RHS if not provided
    if rhs is None:
        rhs_torch = torch.zeros_like(solution_2d, device=device, dtype=dtype)
    else:
        rhs_torch = ensure_tensor_device(rhs, device)
        if rhs_torch.dim() == 1:
            rhs_torch = rhs_torch.reshape(n0, n1)
    
    # Create boundary and interior masks
    bd_mask = torch.ones([n0, n1], device=device, dtype=dtype)
    bd_mask[1:-1, 1:-1] = 0
    int_mask = 1 - bd_mask

    # Compute residual for Helmholtz: -∇²u + k²u = f
    # This becomes: -A @ u + k² * M @ u = f
    # So residual = -A @ u + k² * M @ u - f
    stiffness_term = A_torch @ (int_mask * solution_2d).flatten()
    mass_term = M_torch @ (int_mask * solution_2d).flatten()
    
    # Boundary contribution (similar to Poisson)
    bd_stiffness_term = A_torch @ (bd_mask * solution_2d).flatten()
    bd_mass_term = M_torch @ (bd_mask * solution_2d).flatten()
    
    # Compute residual
    res_flat = int_mask.flatten() * (-stiffness_term + k**2 * mass_term) - int_mask.flatten() * (-(-bd_stiffness_term + k**2 * bd_mass_term)) - (int_mask * rhs_torch).flatten()
    
    # Reshape back to 2D
    res = res_flat.reshape(n0, n1)
    
    if return_norm:
        if norm_type == "inf":
            return torch.max(torch.abs(res))
        elif norm_type == "2":
            return torch.norm(res)
        elif norm_type == "1":
            return torch.sum(torch.abs(res))
        else:
            raise ValueError(f"Unknown norm type: {norm_type}")
    else:
        return res

def compute_residual_with_gradients(
    solution: torch.Tensor,
    geo_coeffs: torch.Tensor,
    spline_space: Tuple,
    equation_type: str = "poisson",
    wave_number: Optional[Union[float, torch.Tensor]] = None,
    rhs: Optional[torch.Tensor] = None,
    return_norm: bool = True,
    norm_type: str = "inf"
) -> torch.Tensor:
    """
    Compute residual with full gradient support for automatic differentiation.
    
    This is a wrapper function that calls the appropriate torch-based residual function.
    
    Args:
        solution: Solution coefficients with BCs already applied
        geo_coeffs: Geometry parametrization coefficients
        spline_space: Tuple of B-spline basis for each dimension
        equation_type: Type of equation ("poisson" or "helmholtz")
        wave_number: Wave number for Helmholtz equation
        rhs: Right-hand side vector
        return_norm: If True, return norm of residual; if False, return residual vector
        norm_type: Type of norm ("inf", "2", or "1")
        
    Returns:
        Residual norm or vector with gradients preserved
    """
    if equation_type == "poisson":
        return compute_poisson_residual(
            solution, geo_coeffs, spline_space, rhs, return_norm, norm_type
        )
    elif equation_type == "helmholtz":
        if wave_number is None:
            raise ValueError("wave_number must be provided for Helmholtz equation")
        return compute_helmholtz_residual(
            solution, geo_coeffs, wave_number, spline_space, rhs, return_norm, norm_type
        )
    else:
        raise ValueError(f"Unknown equation type: {equation_type}")
